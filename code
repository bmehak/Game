import pygame
import math
import time  # Import the time module for managing cooldowns

pygame.init()
window = pygame.display.set_mode((1600, 900))
pygame.display.set_caption('Water Shooter')
clock = pygame.time.Clock()
running = True

# Load images
surf = pygame.image.load('back.jpeg')
fire = pygame.image.load('fire.jpg')
fire1 = pygame.image.load('bullet.jpeg')  # Bullet image for obstacles
ob_image = pygame.image.load('sub1.png')
player_image = pygame.image.load('sub2.jpg')

# Load music
pygame.mixer.music.load('arcade.mp3')
pygame.mixer.music.play(-1)

# Initial positions
x = 1100
y = 300
obstacle_positions = [0, 175, 350, 525, 700]  # Starting Y positions for obstacles
obstacle_active = [True] * len(obstacle_positions)  # Track active status of obstacles
last_shot_times = [0] * len(obstacle_positions)  # Last shot times for each obstacle
shooting_index = 0  # Index of the obstacle that can shoot

# Animation parameters
time_var = 0
speed = 0.02  # Controls the speed of the vertical motion
horizontal_amplitude = 30  # Horizontal movement range

# Projectile lists
player_projectiles = []
obstacle_bullets = []
bullet_speed = 10  # Speed of bullets from obstacles
obstacle_shoot_delay = 1  # Time in seconds for obstacle shooting
change_shooting_delay = 1 # Time in seconds to change the shooting obstacle

# Projectile class for player
class Projectile:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.speed = 10  # Speed of the projectile

    def update(self):
        self.x -= self.speed  # Move left

    def draw(self, surface):
        surface.blit(fire, (self.x, self.y))

    def get_rect(self):
        return pygame.Rect(self.x, self.y, fire.get_width(), fire.get_height())

# Bullet class for obstacles
class Bullet:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.speed = bullet_speed  # Speed of the bullet

    def update(self):
        self.x += self.speed  # Move right

    def draw(self, surface):
        surface.blit(fire1, (self.x, self.y))

    def get_rect(self):
        return pygame.Rect(self.x, self.y, fire1.get_width(), fire1.get_height())

# Shooting control variables for player
can_shoot = True
shoot_delay = 0.4  # Time in seconds for player shooting
last_shot_time = 0  # Timestamp of the last shot

# Timer for changing the shooting obstacle
last_change_time = time.time()

# Player active status
player_active = True

while running:
    # Background
    window.blit(surf, (0, 0))

    # Update and draw obstacles
    for i in range(len(obstacle_positions)):
        if obstacle_active[i]:  # Only draw active obstacles
            # Move the obstacles up and down using a sine wave
            vertical_offset = math.sin(time_var + i) * 20  # Vertical movement
            horizontal_offset = 200 + math.sin(time_var + i) * horizontal_amplitude  # Fixed horizontal position with movement
            window.blit(ob_image, (horizontal_offset, obstacle_positions[i] + vertical_offset))

            # Shooting logic for the current obstacle
            current_time = time.time()  # Get the current time
            if i == shooting_index and current_time - last_shot_times[i] >= obstacle_shoot_delay:
                obstacle_bullets.append(Bullet(horizontal_offset + 220, obstacle_positions[i]))  # Adjust bullet starting position
                last_shot_times[i] = current_time  # Update last shot time for this obstacle

    # Check for collisions between obstacle bullets and player
    if player_active:  # Only check if the player is active
        player_rect = pygame.Rect(x, y, player_image.get_width(), player_image.get_height())
        for bullet in obstacle_bullets:
            if bullet.get_rect().colliderect(player_rect):
                player_active = False  # Deactivate the player
                break  # Exit the loop after one collision

    # Draw player if active
    if player_active:
        window.blit(player_image, (x, y))

    # Update and draw projectiles from player
    for projectile in player_projectiles:
        projectile.update()
        projectile.draw(window)

    # Check for collisions between player projectiles and obstacles
    for i in range(len(obstacle_positions)):
        if obstacle_active[i]:
            obstacle_rect = pygame.Rect(200 + math.sin(time_var + i) * horizontal_amplitude, obstacle_positions[i] + vertical_offset, ob_image.get_width(), ob_image.get_height())
            for projectile in player_projectiles:
                if projectile.get_rect().colliderect(obstacle_rect):
                    obstacle_active[i] = False  # Deactivate the obstacle
                    player_projectiles.remove(projectile)  # Remove the projectile that hit the obstacle
                    break  # Exit the loop after one collision

    # Update and draw bullets from obstacles
    for bullet in obstacle_bullets:
        bullet.update()
        bullet.draw(window)

    # Event loop
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    keys = pygame.key.get_pressed()

    # Player movement
    if player_active:  # Only allow movement if the player is active
        if keys[pygame.K_LEFT] and x >= 400:
            x -= 8
        if keys[pygame.K_RIGHT] and x < 1200:
            x += 8
        if keys[pygame.K_UP] and y > -50:  # Prevent moving off the top
            y -= 8
        if keys[pygame.K_DOWN] and y < 650:  # Prevent moving off the bottom
            y += 8

        # Shooting logic for player
        current_time = time.time()  # Get the current time
        if keys[pygame.K_SPACE] and can_shoot:  # Press space to shoot if allowed
            player_projectiles.append(Projectile(x + 50, y + 20))  # Start projectile slightly right of player
            can_shoot = False  # Set shooting to not allowed
            last_shot_time = current_time  # Record the time of the shot

        # Check if enough time has passed to allow shooting again
        if not can_shoot and current_time - last_shot_time >= shoot_delay:
            can_shoot = True  # Allow shooting again

    # Change shooting obstacle periodically
    if current_time - last_change_time >= change_shooting_delay:
        shooting_index = (shooting_index + 1) % len(obstacle_positions)  # Cycle to the next obstacle
        last_change_time = current_time  # Update the last change time

    # Increment time for obstacle movement
    time_var += speed

    # Update display
    pygame.display.update()
    clock.tick(60)

pygame.quit()
